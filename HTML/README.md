# HTML 学习总结

### 一、 `<label>` 标签的用法
  `label` 标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验

### 二、 如何减少 DOM 数量和优化

  - _2.1 减少 DOM 数量的方法_

    + 可以使用伪元素，阴影实现内容尽量不实用 DOM 实现，如冲出浮动、样式实现等；
    + 按需加载，减少不必要的渲染；
    + 结构合理，语义化标签；
  
  - _2.2 大量 DOM 时的优化_

    > 当对 DOM 元素进行一系列操作时，对 DOM 进行访问和修改 DOM 引起的重绘和重排比较消耗性能，所以关于操作 DOM，应该从以下几点出发：

    + 缓存 DOM 对象：不管在什么场景下，操作 DOM 一般首先会访问 DOM，尤其循环遍历这种时间复杂度可能会比较高的操作。那么可以在循环之前就讲主节点，不必循环的 DOM 节点先获取到，那么在循环里就可以直接引用，而不必去重新查询；
    + 文档片段：利用 `document.createDocumentFragment()` 方法创建文档碎片节点，创建的是一个虚拟的节点对象。向这个节点添加 DOM 节点，修改 DOM 节点并不会影响到真实的 DOM 结构；
    + 虚拟DOM：js 模拟 DOM 树并对 DOM 树操作的一种结束。virtual DOM 是一个纯 JS 对象，所以对他操作会更高效；

### 三、 script 的 async 跟 defer 的区别？

  > 浏览器在执行 HTML 的时候遇到了 `<script>` 时会停止页面的渲染，去下载和执行 js 的文件直接遇见 `</script>` 会继续渲染页面。故浏览器在执行 JS 文件的时候浏览器表现一片空白，为了解决这个问题 ECMAScript 定义了 defer 和 async 两个属性用于控制 JS 的下载和执行。

  - _3.1 defer_ 

    + 红宝书中的解释：这个属性的用途是表明脚本在执行时不会影响页面的构造，也就是说，脚本会被延迟到页面解析完毕后在运行。因此。在 `<script>` 元素中设置属性，相当于告诉浏览器立即下载，但延迟执行。 <br/> HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两哥脚本会咸鱼 DOMContentLoaded 时间执行，因此最好只包含一个延迟脚本。

    + MDN 上的解释：这个布尔属性被设定用来通知浏览器该脚本将在文档解析完成后，触发 DOMContentLoaded 事件执行。如果缺少 src 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。

  - _3.2 async_

    + 红宝书中的解释：这个属性与 defer 类似，都用于改变处理脚本的行为。async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 defer 不同的是，标记为 async 的脚本并不保证按照它们的先后顺序执行。<br/> 第二个脚本文件可能会在第一个脚本之前执行。因此确保两者之间不不互相依赖非常重要。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。

    + MDN 上的解释：该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用（即没有 src 属性的脚本）

  - _3.3 区别_
    
    > 当一个 script 标签内同时包含 defer 和 async 属性时，只会触发 async，不会触发 defer，除非浏览器不兼容 async。

    + **相同点**：
      - 加载文件时不阻塞页面渲染
      - 对与 inline 的 script 无效，当script 标签中间有代码时，两个属性都不会起作用。
      - 使用这两个属性的脚本中不能调用 document.write 方法
      - 有脚本的 onload 的事件回调

    + **不同点**： 
      - HTML4.0 中定义了 defer; 
      - HTML5.0 中定义了 async;
      - 每一个 async 属性的脚本都在它下载结束之后立刻执行，同时回在 window 的 load 事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；
      - 每一个 defer 属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在 document 的DOMContentLoaded 之前执行。

### 四、什么是文档流
  - 将窗体自上而下分成若干行，并在每行中按从左至右的依次排放元素，即为文档流
  - 在常规情况下，文档流总是从左向右从上到下的顺序依次排列
  - 脱离文档流本质上是以独立块元素的形式浮动在文档中。本身不占据文档空间
  - 脱离文档流的方式
    + 浮动
    + 绝对定位
    + 固定定位

### 五、图片上传的方式
  1. html表单上传
    - 使用 `form` 表单的input `[type="file"]` 控件；
    - `form` 表单的 `enctype` 必须是 `multipart/form-data`；
  2. XMLHttpRequest 配合 FormData
    - `XMLHttpRequest` 的 `send` 方法负责发送请求；
    - `FormData` 负责存储图片；
  3. Ajax + formdata 上传
    - `jQuery` 的 `ajax()` 方法负责发送请求；
    - `FormData` 负责存储图片；
  4. 三方插件
    - 百度上传插件 `Web Uploader`；
    - `jQuery` 图片预览插件 `imgPreview`；
    - 拖拽上传与图像预览插件 `Dropzone.js` 等等；

### 六、跨域
  - **什么是跨域**：向`非同源`地址发送 Ajax 请求就是跨域；
  - **什么是非同源**：协议（protocol）、主机（host）和端口号（port）三者之一不同；
  - **什么是浏览器的同源策略**
    + 浏览器上为安全性考虑实施的非常重要的安全策略；
    + 浏览器会限制脚本中发起的跨域请求，比如：使用 `XMLHttpRequest` 对象和 `Fetch` 发起 `HTTP` 请求就必须遵守同源策略；
    + `<script>、<img>、<iframe>、<link>` 等标签都可以加载跨域资源，而不受同源限制；
  - **跨域的常见方案**
    + `JSONP` 是服务器与客户端跨源通信的常用方法，兼容性好（兼容低版本IE），缺点是只支持 `get` 请求，不支持 `post` 请求；
    + `CORS` 是跨域资源分享（Cross-Origin Resource Sharing）的缩，它是 W3C 标准，属于跨源 `AJAX` 请求的根本解决方法；
    + 使用代理服务器，比如 `axios` 可以配置代理解决跨域；
    + 设置 `document.domain` 解决无法读取非同源网页的 `Cookie` 问题；
    + 跨文档通信 API：`window.postMessage()`；

### 七、get 和 post 区别

|  请求方式      |  GET  | POST  |
|  :----:       |  :----:  | :----:  |
|  参数位置       |  URL 的 query | 一般在 content 中，query 也可以 |
|  参数大小       |  受限于浏览器 url 大小，一般不超过 32 k | 1 G |
|  服务器数据接收  |  接收 1 次 | 根据数据大小，可分多次接收 |
|  使用场景(语义)  |  从服务器端获取数据，不做增删改 | 想服务器提交数据，如做增删改操作 |
|  安全性         |  参数携带在 url 中，安全性低 | 相对于 GET 请求，安全性更高 |
